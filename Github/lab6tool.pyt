import arcpyclass Toolbox(object):    def __init__(self):        """Define the toolbox (the name of the toolbox is the name of the        .pyt file)."""        self.label = "My First Toolbox"        self.alias = "toolbox"        # List of tool classes associated with this toolbox        self.tools = [HMTool_q1,DMSTool_q2,BLTool_q3,HWATool_q4,SATool_q5]#Question 1        class HMTool_q1(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "Health Monitor Tool"        self.description = "Please provide your height and weight information to diagnose your health"        self.canRunInBackground = False    def getParameterInfo(self):        """Define parameter definitions"""        param0 = arcpy.Parameter(displayName = "Weight in pounds (lbs)", name = "wt", datatype = "GPString", parameterType = "Required", direction = "Input")        param1 = arcpy.Parameter(displayName = "Height in feet (ft)", name = "ft", datatype = "GPString", parameterType = "Required", direction = "Input")        params = [param0, param1]        return params    def isLicensed(self):        """Set whether tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""        return    def execute(self, parameters, messages):        """The source code of the tool."""        #height = float(input("Please enter your heigh (in feet):"))        height = float(parameters[1].ValueAsText)        #weight = float(input("Please enter your weight (in lbs):"))        weight = float(parameters[0].ValueAsText)        sw = ((height*30.48)-105)/0.454        if weight<sw*0.9:            myWeight = "underweight"        elif sw*0.9<=weight<=sw*1.1:            myWeight = "normal weight"        elif sw*1.1<weight<=sw*1.2:            myWeight = "overweight"        elif sw*1.2<weight<=sw*1.3:            myWeight = "Class I Obesity"        elif sw*1.3<weight<=sw*1.4:            myWeight = "Class II Obesity"        elif sw*1.4<weight:            myWeight = "Class III Obesity"        arcpy.AddMessage("Standard weight = ", "%.3f" % sw)        arcpy.AddMessage("Diagnosis =", myWeight)        return    def postExecute(self, parameters):        """This method takes place after outputs are processed and        added to the display."""        return# Question 2class DMSTool_q2(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "Degree Convertor Tool"        self.description = "To convert degrees, minutes, and seconds (dd:mm:ss) to decimal degrees"        self.canRunInBackground = False    def getParameterInfo(self):        """Define parameter definitions"""        param0 = arcpy.Parameter(displayName = "Degrees", name = "dd", datatype = "GPLong", parameterType = "Required", direction = "Input")        param0.filter.type = "Range"        param0.filter.list = [0, 180]        param1 = arcpy.Parameter(displayName = "Minutes", name = "mm", datatype = "GPLong", parameterType = "Required", direction = "Input")        param1.filter.type = "Range"        param1.filter.list = [0, 60]        param2 = arcpy.Parameter(displayName = "Seconds", name = "ss", datatype = "GPLong", parameterType = "Required", direction = "Input")        param2.filter.type = "Range"        param2.filter.list = [0, 60]        params = [param0, param1, param2]        return params    def isLicensed(self):        """Set whether tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""        return    def execute(self, parameters, messages):        """The source code of the tool."""        degs = float(parameters[0].ValueAsText)        mins = float(parameters[1].ValueAsText)        secs = float(parameters[2].ValueAsText)        decDeg = float(degs) + (float(mins)/60) + (float(secs)/3600)        #arcpy.AddMessage()        arcpy.AddMessage("Value in decimal degrees is:", "%.4f" % decDeg)        return    def postExecute(self, parameters):        """This method takes place after outputs are processed and        added to the display."""        return# Question 3class BLTool_q3(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "Best Location Tool"        self.description = ""        self.canRunInBackground = False    def getParameterInfo(self):        """Define parameter definitions"""        param0 = arcpy.Parameter(displayName = "Pick a city file:", name = "city", datatype = "DETextfile", parameterType = "Required", direction = "Input")        param1 = arcpy.Parameter(displayName = "Pick a location file:", name = "location", datatype = "DETextfile", parameterType = "Required", direction = "Input")        params = [param0, param1]        return params    def isLicensed(self):        """Set whether tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""        return    def execute(self, parameters, messages):        """The source code of the tool."""        cityFile = open(parameters[0].valueAsText,"r")        locationFile = open(parameters[1].valueAsText,"r")        cityLines = cityFile.readlines()[1:]        locationLines = locationFile.readlines()[1:]        locationList = []        for aLocation in locationLines:            sumDistance = 0            locationFlds = aLocation.split(",")            locationX = float(locationFlds[1])            locationY = float(locationFlds[2])            for aCity in cityLines:                cityFlds = aCity.split(",")                cityX = float(cityFlds[1])                cityY = float(cityFlds[2])                dist = ((locationX-cityX)**2+(locationY-cityY)**2)**.5                sumDistance += dist            locationList.append((locationFlds[0], sumDistance))        sortedLocationList = sorted(locationList, key = lambda locationRec:locationRec[1])        arcpy.AddMessage("The best location id is %s" % sortedLocationList[0][0])        arcpy.AddMessage("The best average distance is " + str(sortedLocationList[0][1]/(5240*len(cityLines))))        cityFile.close()        locationFile.close()        return    def postExecute(self, parameters):        """This method takes place after outputs are processed and        added to the display."""        return# Question 4class HWATool_q4(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "Highway Population Analysis Tool"        self.description = ""        self.canRunInBackground = False    def getParameterInfo(self):        """Define parameter definitions"""        hwList = ["I10", "I20", "I40", "I60", "I70", "I75", "I80", "I85", "I90", "I95"]        param0 = arcpy.Parameter(displayName = "Pick a Highway feature class", name = "intFC", datatype = "DEFeatureClass", parameterType = "Required", direction = "Input")        param1 = arcpy.Parameter(displayName = "Pick a city feature class", name = "ctyFC", datatype = "DEFeatureClass", parameterType = "Required", direction = "Input")        param2 = arcpy.Parameter(displayName = "Choose the first Highway", name = "Hwy1", datatype = "GPString", parameterType = "Required", direction = "Input")        param2.filter.type = "ValueList"        param2.filter.list = hwList        param3 = arcpy.Parameter(displayName = "Choose the second Highway", name = "Hwy2", datatype = "GPString", parameterType = "Required", direction = "Input")        param3.filter.type = "ValueList"        param3.filter.list = hwList        param4 = arcpy.Parameter(displayName = "Buffer Distance", name = "BuffDist", datatype = "GPLinearUnit", parameterType = "Required", direction = "Input")        param5 = arcpy.Parameter(displayName = "Pick a Field to Sum", name = "sumFld", datatype = "Field", parameterType = "Required", direction = "Input")        param5.parameterDependencies = [param1.name]        params = [param0, param1, param2, param3, param4, param5]        return params    def isLicensed(self):        """Set whether tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""        return    def execute(self, parameters, messages):        """The source code of the tool."""        # To allow overwriting outputs change overwriteOutput option to True.        arcpy.env.overwriteOutput = True        arcpy.env.workspace = "C:\\Users\\Samuel\\Documents\\GEOG_592\\Lab6\\"        #Section for configuring input data sources        CITIES = parameters[1].valueAsText        interstate = parameters[0].valueAsText        hwyList = [parameters[2].valueAsText, parameters[3].valueAsText]        for aHwy in hwyList:            #process: select (Select) (analysis)            interstate_Select = "interstate_Select.shp"            arcpy.analysis.Select(interstate, interstate_Select, "ROUTE_NUM = '"+aHwy+"'")            # Process: Buffer (Buffer) (analysis)            interstate_Buffer = "interstate_Buffer.shp"            arcpy.analysis.Buffer(interstate_Select, interstate_Buffer, parameters[4].valueAsText, "FULL", "ROUND", "NONE", [], "PLANAR")            # Process: Clip (Clip) (analysis)            Buffer_Clip_Cities = "Buffer_Clip_Cities.shp"            arcpy.analysis.Clip(CITIES, interstate_Buffer, Buffer_Clip_Cities)                        # Process: Summary Statistics (Summary Statistics) (analysis)            #sum_table_dbf = "st"+aHwy+parameters[4].valueAsText+".dbf"            #arcpy.analysis.Statistics(Buffer_Clip_Cities, sum_table_dbf, [[parameters[5].valueAsText, "SUM"]])            #arcpy.AddMessage(aHwy+ " just being completed.")            #sumFldName = "SUM_"+"POP1990"             #sumCursor = arcpy.da.SearchCursor(sum_table_dbf, ["FREQUENCY", sumFldName[:10]]) #ArcGIS Pro only keeps the first 10 characters of a field name            #for aRow in sumCursor:                #cityNum = aRow[0]                #sumResult = aRow[1]                #arcpy.AddMessage("Total number of cities in the highway buffer is " +cityNum)                #arcpy.AddMessage(sumFldName + " is "+ sumResult)        #arcpy.AddMessage("All completed")            # Process: Summary Statistics (Summary Statistics) (analysis)            sumtable_dbf = "Cities"+aHwy+"Buf"+parameters[4].valueAsText+".shp"            arcpy.analysis.Statistics(Buffer_Clip_Cities, sumtable_dbf, [[parameters[5].valueAsText, "SUM"]])        arcpy.AddMessage("All Completed")        return    def postExecute(self, parameters):        """This method takes place after outputs are processed and        added to the display."""        return# Question 5class SATool_q5(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "Suitability Analysis Tool"        self.description = ""        self.canRunInBackground = False    def getParameterInfo(self):        """Define parameter definitions"""        param0 = arcpy.Parameter(displayName = "Slope:", name = "slp", datatype = "GPDouble", parameterType = "Required", direction = "Input")        param0.filter.type = "Range"        param0.filter.list = [0, 1]        param1 = arcpy.Parameter(displayName = "Land Use:", name = "lndUse", datatype = "GPDouble", parameterType = "Required", direction = "Input")        param1.filter.type = "Range"        param1.filter.list = [0, 1]        param2 = arcpy.Parameter(displayName = "Distance to streams:", name = "dst2str", datatype = "GPDouble", parameterType = "Required", direction = "Input")        param2.filter.type = "Range"        param2.filter.list = [0, 1]        params = [param0, param1, param2]        return params    def isLicensed(self):        """Set whether tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""        return    def execute(self, parameters, messages):        """The source code of the tool."""        #from arcpy.sa import                arcpy.CheckOutExtension("Spatial")        arcpy.env.workspace = "C:\\Users\\Samuel\\Documents\\GEOG_592\\Lab5\\SuitabilityModeling\\Data.gdb"        arcpy.env.overwriteOutput = True        value0 = float(parameters[0].ValueAsText)        value1 = float(parameters[1].ValueAsText)        value2 = float(parameters[2].ValueAsText)        # Check out any necessary licenses.        arcpy.CheckOutExtension("3D")        #arcpy.CheckOutExtension("spatial")        arcpy.CheckOutExtension("ImageAnalyst")        # Set Geoprocessing environments        arcpy.env.snapRaster = "C:\\Users\\Samuel\\Documents\\GEOG_592\\Lab5\\SuitabilityModeling\\Data.gdb\\Elevation"        arcpy.env.extent = "439952.113762345 200181.284694512 513122.113762345 253671.284694512"        arcpy.env.cellSize = "30"        arcpy.env.mask = "C:\\Users\\Samuel\\Documents\\GEOG_592\\Lab5\\SuitabilityModeling\\Data.gdb\\Elevation"        Streams = "Streams"        Elevation = arcpy.Raster("Elevation")        LandUse = arcpy.Raster("LandUse")        # Process: Distance Accumulation (Distance Accumulation) (sa)        Distance_Streams = "C:\\Users\\Samuel\\Documents\\GEOG_592\\Lab5\\SuitabilityModeling\\Output.gdb\\Distance_Streams"        Distance_Accumulation = Distance_Streams        backRaster = "C:\\Users\\Samuel\\Documents\\GEOG_592\\Lab5\\SuitabilityModeling\\Output.gdb\\\\backRaster"        Out_source_direction_raster = ""        Out_source_location_raster = ""        Distance_Streams = arcpy.sa.DistanceAccumulation(Streams, "", "", "", "", "BINARY 1 -30 30", "", "BINARY 1 45", backRaster, Out_source_direction_raster, Out_source_location_raster, "", "", "", "", "PLANAR")        Distance_Streams.save(Distance_Accumulation)        backRaster = arcpy.Raster(backRaster)        # Process: Slope (Slope) (sa)        SlopeRaster = "C:\\Users\\Samuel\\Documents\\GEOG_592\\Lab5\\SuitabilityModeling\\Output.gdb\\SlopeRaster"        Slope = SlopeRaster        SlopeRaster = arcpy.sa.Slope(Elevation, "PERCENT_RISE", 0.30480060960121924, "PLANAR", "Foot_US")        SlopeRaster.save(Slope)        # Process: Reclassify (Reclassify) (sa)        Reclass_Slope = "C:\\Users\\Samuel\\Documents\\GEOG_592\\Lab5\\SuitabilityModeling\\Output.gdb\\Reclass_Slope"        Reclassify = Reclass_Slope        Reclass_Slope = arcpy.sa.Reclassify(SlopeRaster, "VALUE", "0 3 0;3 10 3;10 25 6;25 90 10", "DATA")        Reclass_Slope.save(Reclassify)        # Process: Reclassify (2) (Reclassify) (sa)        Reclass_Landuse = "C:\\Users\\Samuel\\Documents\\GEOG_592\\Lab5\\SuitabilityModeling\\Output.gdb\\Reclass_Landuse"        Reclassify_2_ = Reclass_Landuse        Reclass_Landuse = arcpy.sa.Reclassify(LandUse, "VALUE", "1 1;2 1;3 1;4 2;5 8;6 10;7 10;8 10;9 6;10 2;11 10;12 1", "DATA")        Reclass_Landuse.save(Reclassify_2_)        # Process: Rescale by Function (Rescale by Function) (sa)        Rescale_Dist2Stream = "C:\\Users\\Samuel\\Documents\\GEOG_592\\Lab5\\SuitabilityModeling\\Output.gdb\\Rescale_Dist2Stream"        Rescale_by_Function = Rescale_Dist2Stream        Rescale_Dist2Stream = arcpy.sa.RescaleByFunction(Distance_Streams, [["MSSMALL", "", "", "", "", 1, 1, ""]], 1, 10)        Rescale_Dist2Stream.save(Rescale_by_Function)        # Process: Raster Calculator (Raster Calculator) (sa)        SuitableSites = "C:\\Users\\Samuel\\Documents\\GEOG_592\\Lab5\\SuitabilityModeling\\Output.gdb\\SuitableSites"        Raster_Calculator = SuitableSites        SuitableSites =  (Reclass_Slope * value0) + (Reclass_Landuse * value1) + ( Rescale_Dist2Stream * value2)        SuitableSites.save(Raster_Calculator)        arcpy.AddMessage("Suitable sites raster created successfully")        return    def postExecute(self, parameters):        """This method takes place after outputs are processed and        added to the display."""        return